# Copyright 2021 XXXXXXXX (XXXXXXXX @ XXXXX.XXX)
# имя автора скрыто по условиям задания
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------

# pyNotebook - Электронная записная книжка
# первое проектное задание Яндекс.Лицей "второй год"
# ------------------------------------------------------
# имитируется работа простой электронной записной книжки,
# основанной на использовании библиотеки графического
# пользовательского интерфейса Qt5 (PyQt5) и базы данных SQLite3

# Для запуска программы выполнить в командной строке
# рабочего каталога программы:
#   (skiped)@linux_box: python3 pyNotebook.py
# ------------------------------------------------------

# ------------------------------------------------------
# если что-то "пошло не так"
# 1) установить Linux (тестировалось на Linux Mint 2020.1)
# 2) для установки python3 выполнить:
#    (skiped)@linux_box: sudo apt install python3
# 3) для установки библиотек Qt5 и QtDesigner выполнить:
#    (skiped)@linux_box: sudo apt install pyqt5-dev-tools qttools5-dev-tools
# 4) установка SQLite3, как правило, не требуется (подтягивается зависимостями
#    при установке третьего Питона)
# ------------------------------------------------------

# ------------------------------------------------------
# Что собственно программа делает
# ------------------------------------------------------
# После запуска программы отрисовывается главное окно программы,
# содержащее базовые элементы управления:
# 1) метки, обозначающие назначение областей главного окна
# 2) многострочное текстовое поле textEdit_record для отображения
#    и модификации содержимого записной книжки
# 3) календарь calendarWidget для выбора даты
# 4) многострочное текстовое поле plainTextEdit_manual для отображения
#    краткой инструкции по использованию программы
# 5) кнопка pushButton_today для установки текущей даты
# 6) кнопка pushButton_change для фиксации (замены) содержимого записей в книжке
# 7) кнопка pushButton_delete для удаления записей из книжки
# 8) кнопка pushButton_exit для явного выхода из программы

# Алгоритм работы с компьютерной программой предельно прост:
# 1. Нажмите "Сегодня" или выберете дату в календаре
# 2. Если на эту дату в БД была запись, то она отобразится
#    в окне просмотра/коррекции записей
# 3. Запись можно откорректировать или удалить
# 4. После коррекции (создания новой) записи нажмите  "Добавить/заменить запись"
# 5. Для удаления записи нажмите на "Удалить запись".
# 6. При необходимости повторите шаги 1-6
# 7. Для выхода из программы нажмите кнопку "Выход"
# ------------------------------------------------------

# ------------------------------------------------------
# подключаемые модули
# ------------------------------------------------------
# системные функции (используются sys.argv и sys.exit)
import sys
# работа с датой/временем (в записной книжке нужны)
import datetime
# работа с функциями базы данных
import sqlite3

# ------------------------------------------------------
# модули графического пользовательского интерфейса
# ------------------------------------------------------
# Виджеты Qt5
from PyQt5.QtWidgets import *
# общие функции ГПИ библиотеки Qt5 (импортируем все)
from PyQt5.QtGui import *
# функции ядра библиотеки Qt5 (импортируем все)
from PyQt5.QtCore import *
# так как графический пользовательский интерфейс проектировался в QtDesigner,
# то подключаем модуль UIC
from PyQt5 import uic
# ------------------------------------------------------
# Конец блока импорта
# ------------------------------------------------------

# ------------------------------------------------------
# Класс главного окна программы на базе Qt5 имеет следующую структуру
# MainWindow (QMainWindow)
#   L-- calendarWidget (QCalendarWidget)      - виджет календаря
#   L-- plainTextEdit_manual (QPlainTextEdit) - виджет с инструкцией
#   L-- textEdit_record (QtextEdit)           - виджет окна записей в книжке
#   L-- label_manual (QLabel) - метка подписи "Краткая инструкция"
#   L-- label_record (QLabel) - метка подписи "Окно просмотра/коррекции записей"
#   L-- pushButton_change (QPushButton) - кнопка "Добавить/заменить запись"
#   L-- pushButton_delete (QPushButton) - кнопка "Удалить запись"
#   L-- pushButton_exit(QPushButton)    - кнопка "Выход"
#   L-- pushButton_today (QPushButton)  - кнопка "Сегодня"
# ------------------------------------------------------
class Window(QMainWindow):
    # ------------------------------------------------------
    # конструктор класса
    # ------------------------------------------------------
    # решаемые конструктором задачи:
    # 1) проинициализировать главное окно,
    # 2) загрузить интерфейс, созданный в QtDesigner
    # 3) привязать подпрограммы-обработчики событий к виджетам ГПИ
    # 4) выполнить первую прорисовку содержимого виджетов ГПИ
    def __init__(self):
        # инициализируем главное окно, вызывая методы родительского класса
        super(Window, self).__init__()
        # загружаем элементы графического пользовательского интерфейса
        # средствами подсистемы UIC
        uic.loadUi('pyNotebook.ui', self)
        
        # привязываем подпрограммы-обработчики событий к виджетам
        # ------------------------------------------------------
        # при нажатии на кнопку "Сегодня" управление будет передано
        # подпрограмме-методу setToday_proc текущего класса
        self.pushButton_today.clicked.connect(self.setToday_proc)

        # при нажатии на кнопку "Добавить/заменить запись" управление будет
        # передано подпрограмме-методу change_record_proc текущего класса
        self.pushButton_change.clicked.connect(self.change_record_proc)

        # при нажатии на кнопку "Сегодня" управление будет передано
        # подпрограмме-методу delete_record_proc текущего класса
        self.pushButton_delete.clicked.connect(self.delete_record_proc)

        # при нажатии на кнопку "Сегодня" управление будет передано
        # подпрограмме-методу exit_proc текущего класса
        self.pushButton_exit.clicked.connect(self.exit_proc)

        # при выборе даты в календаре щелчком левой кнопки манипулятора "Мышь"
        # управление будет передано подпрограмме-методу change_date_proc
        # текущего класса
        self.calendarWidget.clicked.connect(self.change_date_proc)

        # Явным образом разрешаем пользователю модификацию содержимого
        # многострочного поля записей в записной книжке
        self.textEdit_record.setReadOnly(False)

        # Явным образом запрещаем пользователю модификацию содержимого
        # многострочного поля инструкции пользования программой
        self.plainTextEdit_manual.setReadOnly(True)
        
        # Имитируем нажатие на кнопку "Сегодня"
        # для получения содержимого базы данных на "сегодня" и его вывода
        # в многстрочное поле записей записной книжки
        self.setToday_proc()
    # ------------------------------------------------------
    # конец конструктора главного окна программы
    # ------------------------------------------------------

    # ------------------------------------------------------
    # предопределенная подпрограмма-метод закрытия главного окна Qt5
    # ------------------------------------------------------
    # решаемые в подпрограмме задачи:
    # 1) оповестить пользователя, что приказ о завершении работы получен
    # 2) корректно разорвать соединение с драйвером базы данных SQLite3
    # 3) передать команду на выход из главного цикла ГПИ Qt5
    def closeEvent(self, e):
        # выводим на консоль сообщение о подтверждении получения приказа
        # на нормальное завершение работы программы
        print("Выполняю нормальный выход")
        # если остались незавершенные транзакции, то завершаем их
        con.commit()
        # печатаем подтверждение успешного завершения транзакций курсора
        print("Транзакции курсора завершены")
        # ликвидируем курсор транзакции SQLite3
        cur.close()
        # печатаем подтверждение успешного завершения операции по уничтожению курсора
        print("Курсор уничтожен")
        # закрываем соединение с драйвером базы данных SQLite3
        con.close()
        # печатаем подтверждение успешного разрыва с драйвером базы данных
        print("Соединение с драйвером базы данных закрыто")
    # ------------------------------------------------------
    # конец подпрограммы-метода closeEvent
    # ------------------------------------------------------

    # ------------------------------------------------------
    # подпрограмма-метод корректного выхода из программы
    # ------------------------------------------------------
    # решаемые в подпрограмме задачи:
    # 1) сгенерировать сообщение о закрытии главного окна программы
    def exit_proc(self):
        # генерируем сообщение о закрытии главного окна программы
        wnd.close()
    # ------------------------------------------------------
    # конец подпрограммы-метода exit_proc
    # ------------------------------------------------------

    # ------------------------------------------------------
    # подпрограмма-метод установки "сегодняшней" даты в записной книжке
    # ------------------------------------------------------
    # решаемые в подпрограмме задачи:
    # 1) определить "сегодняшнюю дату"
    # 2) установить виджет "календарь" на сегодняшнюю дату
    # 3) перерисовать содержимое окна записей записной книжки согласно
    #    содержимого базы данных на сегодняшнюю дату
    def setToday_proc(self):
        # извлекаем "сегодняшнюю дату" из глобального объекта datetime
        date_py = datetime.date.today()
        # преобразуем дату в единообразный для программы формат "день.месяц.год"
        date_str = date_py.strftime("%d.%m.%Y")
        # выводим в консоль сообщение о сегдняшней дате
        print("Сегодня " + date_str)
        # устанавливаем виджет "календарь" на сегодняшнюю дату
        self.calendarWidget.setSelectedDate(date_py)
        # выводим в консоль подтверждение об успехе переустановки даты
        # виджета "календарь"
        print("Дата в виджете 'календарь' переустановлена успешно")
        # передаем управление подпрограмме-методу change_date_proc,
        # которая произведет чтение базы данных на дату "сегодня"
        # и выведет содержимое базы данных в окно просмотра/коррекции записей
        # записной книжки
        self.change_date_proc()
    # ------------------------------------------------------
    # конец подпрограммы-метода setToday_proc
    # ------------------------------------------------------

    # ------------------------------------------------------
    # подпрограмма-метод чтения информации из БД записной книжки
    # на указанную в виджете Календарь
    # ------------------------------------------------------
    # 1) определить дату модифицируемой записи
    # 2) сформировать единообразный строковый формат даты, понятный SQL-запросу
    # 3) сформировать корректный SQL-запрос на чтение информации из базы данных
    # 4) извлечь информацию из БД
    # 5) если в БД было несколько записей на указанную дату, то соединить их
    #    в один текстовый блок
    # 6) вывести извлеченную из БД информацию в консоль и в виджет ГПИ
    # 7) отчитаться об успешном выполнении команды
    def change_date_proc(self):
        # определяем какая дата была выбрана пользователем в виджете Календарь
        print('Выбираю дату')
        date_calendar = self.calendarWidget.selectedDate()
        # преобразуем дату из формата Qt5 в формат даты Python3
        date_py = date_calendar.toPyDate()
        # формируем единообразный строковый формат даты, понятный SQL-запросу
        date_str = date_py.strftime("%d.%m.%Y")
        # выводим в консоль в текстовом виде выбранную дату
        print(date_str)
        # выводим в консоль сообщение, что все готово к поиску записи в БД
        print("читаю базу данных.")
        # посылаем SQL-запрос поиска всех записей из БД на указанную дату
        cur.execute(f"SELECT record FROM nb_records WHERE date='{date_str}'")
        # сообщаем драйверу БД намерение найти все вхождения записи
        # за одну транзакцию
        records = cur.fetchall()
        # приказываем драйверу БД выполнить запрос немедленно
        con.commit()
        # если в БД не было записей на указанную дату, то
        # сообщить об это пользователю и перерисовать окно ГПИ виджета
        # содержимого записей записной книжки
        if len(records) == 0:
            # выводим в консоль сообщение, что записей на указанную дату в БД нет
            print(f"на дату {date_str} записей в книжке нет")
            # перерисовываем виджет отображения содержимого записей книжки
            self.textEdit_record.setText(f"на дату {date_str} записей в книжке нет")
        # если в базе данных искомые записи были найдены, то сгруппируем их
        # и выведем в консоль и в виджет ГПИ
        else:
            # первую найденную запись запоминаем без излишних ухищрений
            record_str = records[0][0]
            # остальные записи на указанную дату, если они есть в ответе на запрос
            # сгруппируем в несколько абзацев
            for row in records[1:]:
                record_str = record_str + "\n" + row[0]
            # выводим в консоль содержимое записей книжки
            print(record_str)
            # перерисовываем виджет отображения содержимого записей книжки
            self.textEdit_record.setText(record_str)
    # ------------------------------------------------------
    # конец подпрограммы-метода change_date_proc
    # ------------------------------------------------------

    # ------------------------------------------------------
    # подпрограмма-метод модификации записи в записной книжке
    # ------------------------------------------------------
    # 1) определить дату модифицируемой записи
    # 2) извлечь модифицированную текстовую информацию из виджета ГПИ
    # 3) сформировать корректный SQL-запрос на модификацию записи в базе данных
    # 4) отчитаться об успешном выполнении команды
    def change_record_proc(self):
        # выводим в консоль сообщение о намерении заменить запись в книжке
        print("Меняю/добавляю запись в записную книжку")
        # сообщаем, что начался процесс извлечения устанвленной в календаре даты
        print("Выбираю дату")
        # определяем какая дата была выбрана пользователем в виджете Календарь
        date_calendar = self.calendarWidget.selectedDate()
        # преобразуем дату из формата Qt5 в формат даты Python3
        date_py = date_calendar.toPyDate()
        # формируем единообразный строковый формат даты, понятный SQL-запросу
        date_str = date_py.strftime("%d.%m.%Y")
        # выводим в консоль в текстовом виде выбранную дату
        print(date_str)
        # сообщаем, что пошел процесс извлечения модифицировнной записи из виджета
        print("Читаю содержимое окна записи")
        # извлекаем из виджета записи все его строковое содержимое
        record_str = self.textEdit_record.toPlainText()
        # выводим в консоль в содержимое окна модифицированной записи
        print(record_str)
        # выводим в консоль сообщение, что все готово к замене записи в БД
        print("Меняю/добавляю запись в базе данных")
        # посылаем SQL-запрос на замену всех записей из БД на указанную дату
        cur.execute("REPLACE INTO nb_records (date, record) " +
                    f"VALUES ('{date_str}','{record_str}')")
        # приказываем драйверу БД выполнить запрос немедленно
        con.commit()
        # печатем в консоль сообщение об успешном исполнении команды
        print("OK")
    # ------------------------------------------------------
    # конец подпрограммы-метода change_record_proc
    # ------------------------------------------------------

    # ------------------------------------------------------
    # подпрограмма-метод удаления записи из записной книжки
    # ------------------------------------------------------
    # 1) определить "дату удаляемой записи"
    # 2) сформировать корректный SQL-запрос на удаление записи из базы данных
    # 3) перерисовать содержимое окна записей записной книжки, указав,
    #    что теперь на выбранную дату записей в записной книжке нет
    def delete_record_proc(self):
        # выводим в консоль сообщение о намерении удалить запись из книжки
        print("Удаляю запись из записной книжки")
        # сообщаем, что начался процесс извлечения устанвленной в календаре даты
        print("Выбираю дату")
        # определяем какая дата была выбрана пользователем в виджете Календарь
        date_calendar = self.calendarWidget.selectedDate()
        # преобразуем дату из формата Qt5 в формат даты Python3
        date_py = date_calendar.toPyDate()
        # формируем единообразный строковый формат даты, понятный SQL-запросу
        date_str = date_py.strftime("%d.%m.%Y")
        # выводим в консоль в текстовом виде выбранную дату
        print(date_str)
        # выводим в консоль сообщение, что все готово к удалению записи из БД
        print("Удаляю запись из базы данных")
        # посылаем SQL-запрос на удаление всех записей из БД на указанную дату
        cur.execute(f"DELETE FROM nb_records WHERE date='{date_str}'")
        # приказываем драйверу БД выполнить запрос немедленно
        con.commit()
        # перерисовываем содержимое окно записей записной книжки так,
        # чтобы пользователь ГПИ видел, что теперь в записной книжке
        # на выбранную им дату записей действительно нет
        self.textEdit_record.setText(f"на дату {date_str} записей в книжке нет")
        # выводим в консоль сообщение об успешном исполнении команды
        # по уничтожению записи на выбранную дату из записной книжки
        print("OK")
    # ------------------------------------------------------
    # конец подпрограммы-метода delete_record_proc
    # ------------------------------------------------------
# ------------------------------------------------------
# Конец класса главного окна программы
# ------------------------------------------------------

# ------------------------------------------------------
# точка входа в программу
# ------------------------------------------------------
# задачи, решаемые на точке входа:
# 1) убедиться, что точка входа действительно родная точка входа главного модуля
# 2) произвести соединение с драйвером баз данных SQLite3
# 3) убедиться, что файл базы данных pyNotebook.db в формате SQLite3 существует
#    и расположен в рабочем каталоге программы
# 4) если файла-базы данных нет на месте, то пересоздать его
# 5) убедиться, что пересоздание файла базы данных прошло успешно
# 6) если не получилось пересоздать файл базы данных, то
#    вывести диагностические сообщения в консоль (вероятнее всего,
#    файловая система была смонтирована в режиме "только для чтения",
#    что исключает работу программы) и прервать работу программы
# 7) создать экземпляр ГПИ Qt5 от класса QApplication
# 8) создать главное окно ГПИ программы в памяти ЭВМ
# 9) показать главное окно ГПИ программы на мониторе
# 10) войти в главный цикл программы с ГПИ Qt5

# проверяем, что мы находимся в главном модуле программы
# и если это действительно так, то работаем дальше
if __name__ == '__main__':
    # выводим в консоль название программы
    print("Электронная записная книжка")
    
    # устанавливаем соединение с драйвером баз данных SQLite3
    try:
        # заранее обозначаем намерение работать с базой данный pyNotebook.db
        con = sqlite3.connect('pyNotebook.db')
    except:
        # если не получилось, то выводим в консоль диагностическое сообщение
        print("нет соединения с базой данных или не установлен модуль sqlite3")
        # и прекращаем работу программы с кодом ошибки 0
        exit(0)
    finally:
        pass

    # выводим в консоль диагностическое сообщение об установленной версии SQLite
    print("найден sqlite3 " + sqlite3.sqlite_version)

    # создаем курсор базы данных, при помощи (посредничестве) которого
    # ведется вся дальнейшая работа с базой данных
    cur = con.cursor()

    # проверяем наличие файла базы данных в рабочем каталоге программы.
    # в случае ошибки попытаемся пересоздать этот файл
    try:
        # выводим в консоль сообщение о намерении проверить наличие файла
        # pyNotebook.py базы данных
        print("проверяю наличие файла базы данных pyNotebook.db")
        # для этого формируем "фиктивный" запрос, который обязательно
        # выполнится только на исправной базе данных
        cur.execute("SELECT date,record from nb_records")
        # так как запросы к базам данных могут иметь отложенный характер, то
        # нужно отдать приказ о принудительном исполнении запроса
        con.commit()
        # если мы здесь, то все в порядке и можно рапортовать об успехе
        print("OK")
    except:
        # если мы здесь, то файла pyNotebook.py в рабочем каталоге программы нет
        # выводим в консоль сообщение об отсутствии этого файла
        print("Файл базы данных pyNotebook.db не найден или поврежден")
        # выводим в консоль сообщение о намерении пересоздать файл базы данных
        print("Пытаюсь пересоздать базу данных.")
        try:
            # Отдаем SQL-запрос на создание новой базы данных с нужной нам
            # внутренней структурой:
            #   одна таблица nb_records
            #   два столбца в этой таблице:
            #     date - типа DATE (реально типа "дата" в SQLite3 нет
            #                       это строковый тип)
            #     record - типа STRING
            #   для ускорения работы с БД объявляем столбец DATE первичным ключевым
            cur.execute("CREATE TABLE nb_records " +
                        "(date DATE PRIMARY KEY, record STRING);")
            # отдаем приказ о немедленном исполнении запроса
            # если приказ окажется не выполненным, то это означает об ошибке создания
            # файла базы данных в рабочем каталоге (наиболее часто такая ошибка
            # возникает при монтировании рабочего каталога программы в режиме
            # "только для чтения").
            con.commit()
            # оглашаем в консоль намерение о проверке создания базы данных
            print("Проверяю повторно наличие файла базы данных pyNotebook.db")
            # формируем "фиктивный" запрос, который выполнится
            # только на исправной базе данных
            cur.execute("SELECT * from nb_records")
            # принуждаем драйвер SQLite3 немедленно выполнить приказ
            con.commit()
            # если мы здесь, то все в порядке и новая база данных
            # готова к работе
            print("OK")
        except:
            # если мы здесь, то все плохо.
            # файла с базой данных в рабочем каталоге не было и создать его
            # не получилось.
            # выводим в консоль диагностические сообщения
            print("Файл базы данных пересоздать не удалось.")
            print("Возможно файловая система смонтирована 'только для чтения'.")
            print("Создайте файл базы данных pyNotebook.db вручную")
            print("или разрешите запись в рабочий каталог с программой.")
            # и прекращаем работу программы с кодом ошибки 0
            exit(0)
        finally:
            pass
    finally:
        pass

    # ------------------------------------------------------
    # переключение в графический режим интефейса программы
    # ------------------------------------------------------
    # выводим в консоль сообщение о запуске ГПИ
    print("Включаю графический пользовательский интерфейс Qt5")
    
    # ------------------------------------------------------
    # протокол создания ГПИ Qt5
    # ------------------------------------------------------
    # 1) создать объект-экземпляр App от класса QApplication
    # 2) создать главное окно ГПИ Qt5
    # 3) отобразить главное окно ГПИ Qt5 на дисплее ЭВМ
    # 4) войти в "бесконечный" цикл обработки сообщение от виджетов ГПИ Qt5
    # ------------------------------------------------------

    # создаем объект-экземпляр App от класса QApplication
    app = QApplication(sys.argv)

    # создаем главное окно ГПИ Qt5
    wnd = Window()

    # отображаем главное окно ГПИ Qt5 на дисплее ЭВМ
    wnd.show()
    
    # входим в "бесконечный" цикл обработки сообщение от виджетов ГПИ Qt5.
    # выход из этого цикла, например, при получении сигнала закрытия программы
    # приведет в вызову подпрограммы sys.exit и окончательному выходу из
    # программы
    sys.exit(app.exec())
# ------------------------------------------------------
# Конец файла pyNotebook.py
# ------------------------------------------------------
